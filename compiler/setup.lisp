(in-package "BSP.COMPILER")
(defun link-op (op)
  (declare (type op op))
  (map nil (lambda (dst)
             (setf (var-op dst) op))
       (op-dsts op)))

(defun mark-op (op)
  (declare (type op op))
  (when (livep op)
    (return-from mark-op))
  (set-live op)
  (when (reducer-p op)
    (map nil (lambda (var)
               (mark-vec var))
         (op-dsts op)))
  (map nil (lambda (mask)
             (set-mask mask)
             (mark-vec mask))
       (op-masks op))
  (map nil (lambda (var)
             (when (typep var 'vec)
               (mark-vec var)))
       (op-args op)))

(defun mark-vec (vec)
  (declare (type vec vec))
  (when (livep vec)
    (return-from mark-vec))
  (set-live vec)
  (let ((op (var-op vec)))
    (cond (op
           (mark-op op))
          (t
           (assert (or (initial-element-of vec)
                       (data-of vec)))))))

(defun vector-union (x y)
  (declare (type simple-vector x y))
  (let ((seen (make-hash-table))
        (acc  (make-array (+ (length x)
                             (length y))
                          :fill-pointer 0)))
    (flet ((mark (x)
             (unless (gethash x seen)
               (setf (gethash x seen) t)
               (vector-push-extend x acc))))
      (map nil #'mark x)
      (map nil #'mark y)
      (coerce acc 'simple-vector))))

(defun setup-state (roots ops reducers)
  (declare (type (simple-array vec 1) roots)
           (type (simple-array op  1) ops)
           (type (simple-array reducer 1) reducers))
  (let ((ops (vector-union ops reducers)))
    (map nil #'link-op ops)
    (map nil (lambda (root)
               (set-root root)
               (mark-vec root))
         roots)
    (map nil #'mark-op reducers)
    ops))
